
PARSER_BEGIN(SPL1)
package parser;

import implementations.PLDeclaration;
import program.Program;
import implementations.Id;
import implementations.FeatureNameDeclaration;
import implementations.Types;
import implementations.Formula;
import implementations.UnaryFormula;
import implementations.BinaryFormula;
import implementations.NotForm;
import implementations.ImpliesForm;
import implementations.AndForm;
import implementations.OrForm;
import implementations.FormDeclaration;
import implementations.ProductDeclaration;
import java.util.*;


public class SPL1 {

  public static void main(String[] args) throws ParseException{
      System.out.println("SPL PLP Parser Version 0.0.1:  Reading from standard input . . .");
     SPL1 spl1 = new SPL1(System.in);
     try{
        Program program = spl1.processInput();
  } catch (Exception e)
        {
          System.out.println("SPL PLP Parser Version 0.0.1:  Encountered errors during parse.");
          e.printStackTrace();
        }


}}


PARSER_END(SPL1)

SKIP : /* WHITE SPACE */{
   " "
   | "\t"
   | "\n"
   | "\r"
   | "\f"
}

TOKEN : /* SEPARATORS */
{
  < LBRACE : "{" >
| < RBRACE : "}" >
| < SEMICOLON : ";" >
| < COMMA : "," >
}

TOKEN : /* TOKENS declaration */
{
  < PRODUCTLINE : "PL" >
  | <FEATURENAME : "FeatureName">
  | <EXTENDS : "extends">
  | <AS : "as">
  | <FORMULA: "Formula">
  | <PRODUCT : "Product">
}

TOKEN : /* TOKENS types */
{
  < ROOT_TYPE : "ROOT" >
  | <MANDATORY_TYPE: "MANDATORY">
  | <OPTIONAL_TYPE: "OPTIONAL">
  | <ALTERNATIVE_TYPE: "ALTERNATIVE">
  | <OR_TYPE: "OR">

  }

TOKEN : /* OPERATORS */
{
 < ASSIGN : "=" >

}

TOKEN : /* TOKENS of Formulas */
{

<IMPLIES : "implies">
| < AND : "and" >
| < OR : "or" >
| < NOT : "not" >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < #LETTER : [ "\u0024", "\u0041"-"\u005a", "\u005f", "\u0061"-"\u007a", "\u00c0"-"\u00d6", "\u00d8"-"\u00f6", "\u00f8"-"\u00ff", "\u0100"-"\u1fff", "\u3040"-"\u318f", "\u3300"-"\u337f", "\u3400"-"\u3d2d", "\u4e00"-"\u9fff", "\uf900"-"\ufaff" ] >
| < #DIGIT : [ "\u0030"-"\u0039", "\u0660"-"\u0669", "\u06f0"-"\u06f9", "\u0966"-"\u096f", "\u09e6"-"\u09ef", "\u0a66"-"\u0a6f", "\u0ae6"-"\u0aef", "\u0b66"-"\u0b6f", "\u0be7"-"\u0bef", "\u0c66"-"\u0c6f", "\u0ce6"-"\u0cef", "\u0d66"-"\u0d6f", "\u0e50"-"\u0e59", "\u0ed0"-"\u0ed9", "\u1040"-"\u1049" ] >
}

Program processInput() :
{
  Program rretorn;
}
{
  rretorn = PProgram() < EOF >
  {
    return rretorn;
  }
}

Program PProgram() :
{
  PLDeclaration plDeclaration = null;
}
{
  plDeclaration = PPLDeclaration()
  {
    return new Program(plDeclaration);
  }
}

PLDeclaration PPLDeclaration() :
{
  FeatureNameDeclaration featureNameDeclaration;
  FormDeclaration formDeclaration;
  ProductDeclaration productDeclaration;
  Id plName;
}
{
  < PRODUCTLINE> plName = PId() < LBRACE > [((featureNameDeclaration = PFNDeclaration()) <SEMICOLON>)+ [ formDeclaration = PFormDeclaration() <SEMICOLON> ] [ (productDeclaration = PProductDeclaration() <SEMICOLON>)+ ] ]< RBRACE >
  {
    return new PLDeclaration(plName);
  }
}

FeatureNameDeclaration PFNDeclaration() :
{
  Id fnName = null;
  Id extendedNode = null;
  Types type = null;
}
{
  < FEATURENAME> fnName = PId() [<EXTENDS> extendedNode = PId()] <AS> type = PType()
  {
    return new FeatureNameDeclaration(fnName, extendedNode, type);
  }
}

FormDeclaration PFormDeclaration() :
{
  Formula formula;
  Id formName;
}
{
  < FORMULA > formName = PId() <ASSIGN> formula = PFormula()
  {
    return new FormDeclaration(formName, formula);
  }
}

ProductDeclaration PProductDeclaration() :
{
  List<Id> featuresSelected;
  Id productName;
}
{
  < PRODUCT> productName = PId() <ASSIGN> <LBRACE> featuresSelected = PFeatureSelected() <RBRACE>
  {
    return new ProductDeclaration(productName, featuresSelected);
  }
}

List<Id> PFeatureSelected():
{
    Id featureSelected;
    List<Id> featuresSelected = new ArrayList<>();

}{
    featureSelected = PId()
    { featuresSelected.add(featureSelected); }
    (<COMMA> featureSelected = PId()
       {featuresSelected.add(featureSelected); })*
{ return featuresSelected;
    }
}

Formula PFormula() :
{
  Formula formula;
}
{
    formula = PBinaryFormula()
  {
    return formula;
  }
}


Formula PUnaryFormula() :
{
  Formula formula;
}
{
  (
    formula = PNotForm()
    | formula = PId()
  )
  {
    return formula;
  }
}

NotForm PNotForm() :
{
  Formula formula;
}
{
  < NOT > formula = PFormula()
  {
    return new NotForm(formula);
  }
}

Formula PBinaryFormula() :
{
  Formula formula;
}
{
    formula = PBinaryFormula2()

 {
    return formula;
}
}

Formula PBinaryFormula2() :
{
  Formula formula, param2;
}
{
    formula = PBinaryFormula3()
    ( <OR> param2 = PBinaryFormula3()
        { formula = new OrForm(formula, param2);}
      | <IMPLIES> param2 = PBinaryFormula3()
        { formula = new ImpliesForm(formula, param2);}
      | <AND> param2 = PBinaryFormula3()
        { formula = new AndForm(formula, param2);}
    )*

 {
    return formula;
}
}

Formula PBinaryFormula3() :
{
  Formula formula;
}
{
    formula = PUnaryFormula()

 {
    return formula;
}
}


Types PType() :
{
  Types type;
}{
    <ROOT_TYPE> { return type = Types.ROOT;}
    | <MANDATORY_TYPE> {return type = Types.MANDATOYRY;}
    | <OPTIONAL_TYPE> {return type = Types.OPTIONAL;}
    | <ALTERNATIVE_TYPE>  {return type = Types.ALTERNATIVE;}
    | <OR_TYPE> {return type = Types.OR;}

}

Id PId() :
{
  Token token;
}
{
  token = < IDENTIFIER >
  {
    return new Id(token.toString());
  }
}